# Crypto

## 签到-y1ng

> 题解

1. base64

> BJD{W3lc0me_T0_BJDCTF}

## 老文盲了

> 题解

1. 拼音查询

> BJD{淛匶襫黼瀬鎶軄鶛驕鳓哵}

## cat_flag

> 题解

1. 每行8bit对应ASCII码

> BJD{M!a0~}

## 灵能精通-y1ng

> 题解

1. 变种猪圈密码

> flag{IMKNIGHTSTEMPLAR}

## 燕言燕语-y1ng

> 题解

1. 转成ASCII码
2. 维基亚密码解密，密钥yanzi

> BJD{yanzi_jiushige_shabi}

## Y1nglish-y1ng

> 题解

1. [在线解密](https://quipqiup.com/)
2. Cr4cy --> Cr4ck

> BJD{pyth0n_Brut3_f0rc3_oR_quipquip_AI_Cr4ck}

## rsa0

> 题解

```python
import gmpy2
from Crypto.Util.number import *

# a = p + q
# b = p - q
# c = c
# e = e

n = (a**2 - b**2) // 4
d = int(gmpy2.invert(e, n - a + 1))
print(long_to_bytes(pow(c, d, n)))
```

> flag{3b5f314b-7efc-4bd9-9f47-bf964ee7bd81}

## rsa1

> 题解

```python
import gmpy2
from Crypto.Util.number import *


# (p - q)^2 = p^2 + q^2 - 2pq ===> b^2 = a - 2n ===> n = (a - (b**2)) // 2
n = (a - (b**2)) // 2

a = # p^2 + q ^ 2
b = # p - q
c = # c
e = # e

# (p + q)^2 = p^2 + q^2 + 2pq
p_q = gmpy2.iroot(a + 2 * n, 2)[0]
# (p - 1) * (q - 1) = pq - (p + q) + 1
d = int(gmpy2.invert(e, n - p_q + 1))
p = pow(c, d, n)
print(long_to_bytes(p))
```

> flag{1b0ad21b-d258-480e-a816-938552486532}

## RSA

> 知识点：爆破e，分解n

> 题解

```python
import gmpy2
from Crypto.Util.number import getPrime, bytes_to_long, long_to_bytes

"""
c = m ^ e mode n
m = c ^ d mode n
"""

# m1 = flag
m2 = 294
m3 = bytes_to_long(b"BJD" * 32)

c1 = 12641635617803746150332232646354596292707861480200207537199141183624438303757120570096741248020236666965755798009656547738616399025300123043766255518596149348930444599820675230046423373053051631932557230849083426859490183732303751744004874183062594856870318614289991675980063548316499486908923209627563871554875612702079100567018698992935818206109087568166097392314105717555482926141030505639571708876213167112187962584484065321545727594135175369233925922507794999607323536976824183162923385005669930403448853465141405846835919842908469787547341752365471892495204307644586161393228776042015534147913888338316244169120
c2 = 381631268825806469518166370387352035475775677163615730759454343913563615970881967332407709901235637718936184198930226303761876517101208677107311006065728014220477966000620964056616058676999878976943319063836649085085377577273214792371548775204594097887078898598463892440141577974544939268247818937936607013100808169758675042264568547764031628431414727922168580998494695800403043312406643527637667466318473669542326169218665366423043579003388486634167642663495896607282155808331902351188500197960905672207046579647052764579411814305689137519860880916467272056778641442758940135016400808740387144508156358067955215018
c3 = 979153370552535153498477459720877329811204688208387543826122582132404214848454954722487086658061408795223805022202997613522014736983452121073860054851302343517756732701026667062765906277626879215457936330799698812755973057557620930172778859116538571207100424990838508255127616637334499680058645411786925302368790414768248611809358160197554369255458675450109457987698749584630551177577492043403656419968285163536823819817573531356497236154342689914525321673807925458651854768512396355389740863270148775362744448115581639629326362342160548500035000156097215446881251055505465713854173913142040976382500435185442521721

# p1 = Random
# p2 = p1
# p3 = Random

# q1 = Random
# q2 = q1
# q3 = q1

# n1 = p1 * q1
n1 = 13508774104460209743306714034546704137247627344981133461801953479736017021401725818808462898375994767375627749494839671944543822403059978073813122441407612530658168942987820256786583006947001711749230193542370570950705530167921702835627122401475251039000775017381633900222474727396823708695063136246115652622259769634591309421761269548260984426148824641285010730983215377509255011298737827621611158032976420011662547854515610597955628898073569684158225678333474543920326532893446849808112837476684390030976472053905069855522297850688026960701186543428139843783907624317274796926248829543413464754127208843070331063037
# n2 = p1 * q1
n2 = n1
# n3 = p3 * q1
n3 = 12806210903061368369054309575159360374022344774547459345216907128193957592938071815865954073287532545947370671838372144806539753829484356064919357285623305209600680570975224639214396805124350862772159272362778768036844634760917612708721787320159318432456050806227784435091161119982613987303255995543165395426658059462110056431392517548717447898084915167661172362984251201688639469652283452307712821398857016487590794996544468826705600332208535201443322267298747117528882985955375246424812616478327182399461709978893464093245135530135430007842223389360212803439850867615121148050034887767584693608776323252233254261047

for i in range(100000):
    if gmpy2.powmod(m2, i, n2) == c2:
        e = i
        print(f"e={i}")
        break

p = gmpy2.gcd(n1, n3)
q1 = n1 // p
q2 = n3 // p

d = gmpy2.invert(e, (p - 1) * (q1 - 1))
m1 = gmpy2.powmod(c1, d, n1)
print(long_to_bytes(m1))
# BJD{p_is_common_divisor}
```

> flag{p_is_common_divisor}

## signin

> 知识点：Hex转ASCII

> 题解

```python
print(bytes.fromhex("424a447b57653163306d655f74345f424a444354467d"))
```

> flag{We1c0me_t4_BJDCTF}

## 这是base??

> 知识点：密码替换

> 题解

```python
import string
import base64

# base64字符表
base64_str_table = string.ascii_uppercase + string.ascii_lowercase + string.digits + "+/"
dicts = {0: 'J', 1: 'K', 2: 'L', 3: 'M', 4: 'N', 5: 'O', 6: 'x', 7: 'y', 8: 'U', 9: 'V', 10: 'z', 11: 'A', 12: 'B', 13: 'C', 14: 'D', 15: 'E', 16: 'F', 17: 'G', 18: 'H', 19: '7', 20: '8', 21: '9', 22: 'P', 23: 'Q', 24: 'I', 25: 'a', 26: 'b', 27: 'c', 28: 'd', 29: 'e', 30: 'f', 31: 'g', 32: 'h', 33: 'i', 34: 'j', 35: 'k', 36: 'l', 37: 'm', 38: 'W', 39: 'X', 40: 'Y', 41: 'Z', 42: '0', 43: '1', 44: '2', 45: '3', 46: '4', 47: '5', 48: '6', 49: 'R', 50: 'S', 51: 'T', 52: 'n', 53: 'o', 54: 'p', 55: 'q', 56: 'r', 57: 's', 58: 't', 59: 'u', 60: 'v', 61: 'w', 62: '+', 63: '/', 64: '='}
dicts = {v: k for k, v in dicts.items()}
c = "FlZNfnF6Qol6e9w17WwQQoGYBQCgIkGTa9w3IQKw"

ss = "".join([base64_str_table[dicts[v]] for v in c])
ss = base64.b64decode(ss)
print(ss)
# BJD{D0_Y0u_kNoW_Th1s_b4se_map}
```

> flag{D0_Y0u_kNoW_Th1s_b4se_map}

## easyrsa

> 知识点：数学知识

> 题解

```python
import gmpy2
from Crypto.Util.number import long_to_bytes


# z=Fraction(1,Derivative(arctan(p),p))-Fraction(1,Derivative(arth(q),q))

# 求导
# Derivative(arctan(p),p) = 1 / (1 + p^2)
# Derivative(arth(q),q) = 1 / (1 - q^2)

# 求分数
# Fraction(1,Derivative(arctan(p),p)) = 1 / (1 / (1 + p^2)) = 1 + p^2
# Fraction(1,Derivative(arth(q),q)) = 1 / (1 / (1 - q^2)) = 1 - q^2

c = 7922547866857761459807491502654216283012776177789511549350672958101810281348402284098310147796549430689253803510994877420135537268549410652654479620858691324110367182025648788407041599943091386227543182157746202947099572389676084392706406084307657000104665696654409155006313203957292885743791715198781974205578654792123191584957665293208390453748369182333152809882312453359706147808198922916762773721726681588977103877454119043744889164529383188077499194932909643918696646876907327364751380953182517883134591810800848971719184808713694342985458103006676013451912221080252735948993692674899399826084848622145815461035
z = 32115748677623209667471622872185275070257924766015020072805267359839059393284316595882933372289732127274076434587519333300142473010344694803885168557548801202495933226215437763329280242113556524498457559562872900811602056944423967403777623306961880757613246328729616643032628964072931272085866928045973799374711846825157781056965164178505232524245809179235607571567174228822561697888645968559343608375331988097157145264357626738141646556353500994924115875748198318036296898604097000938272195903056733565880150540275369239637793975923329598716003350308259321436752579291000355560431542229699759955141152914708362494482
n = 15310745161336895413406690009324766200789179248896951942047235448901612351128459309145825547569298479821101249094161867207686537607047447968708758990950136380924747359052570549594098569970632854351825950729752563502284849263730127586382522703959893392329333760927637353052250274195821469023401443841395096410231843592101426591882573405934188675124326997277775238287928403743324297705151732524641213516306585297722190780088180705070359469719869343939106529204798285957516860774384001892777525916167743272419958572055332232056095979448155082465977781482598371994798871917514767508394730447974770329967681767625495394441
e = 65537
# z = p^2 + q^2
# (p + q)^2 = p^2 + q^2 + 2pq
pq1 = int(gmpy2.iroot(z + 2 * n, 2)[0])

# (p - 1) * (q - 1) = pq - (p + q) + 1
d = gmpy2.invert(e, n - pq1 + 1)

m = gmpy2.powmod(c, d, n)
m = long_to_bytes(m)
print(m)
# BJD{Advanced_mathematics_is_too_hard!!!}
```

> flag{Advanced_mathematics_is_too_hard!!!}

## rsa_output

> 知识点：共模攻击

```python
import gmpy2
from Crypto.Util.number import long_to_bytes

e1 = 2767
e2 = 3659
n = 21058339337354287847534107544613605305015441090508924094198816691219103399526800112802416383088995253908857460266726925615826895303377801614829364034624475195859997943146305588315939130777450485196290766249612340054354622516207681542973756257677388091926549655162490873849955783768663029138647079874278240867932127196686258800146911620730706734103611833179733264096475286491988063990431085380499075005629807702406676707841324660971173253100956362528346684752959937473852630145893796056675793646430793578265418255919376323796044588559726703858429311784705245069845938316802681575653653770883615525735690306674635167111
m1 = 20152490165522401747723193966902181151098731763998057421967155300933719378216342043730801302534978403741086887969040721959533190058342762057359432663717825826365444996915469039056428416166173920958243044831404924113442512617599426876141184212121677500371236937127571802891321706587610393639446868836987170301813018218408886968263882123084155607494076330256934285171370758586535415136162861138898728910585138378884530819857478609791126971308624318454905992919405355751492789110009313138417265126117273710813843923143381276204802515910527468883224274829962479636527422350190210717694762908096944600267033351813929448599
m2 = 11298697323140988812057735324285908480504721454145796535014418738959035245600679947297874517818928181509081545027056523790022598233918011261011973196386395689371526774785582326121959186195586069851592467637819366624044133661016373360885158956955263645614345881350494012328275215821306955212788282617812686548883151066866149060363482958708364726982908798340182288702101023393839781427386537230459436512613047311585875068008210818996941460156589314135010438362447522428206884944952639826677247819066812706835773107059567082822312300721049827013660418610265189288840247186598145741724084351633508492707755206886202876227

gcd, s, t = gmpy2.gcdext(e1, e2)

if s < 0:
    s = -s
    m1 = gmpy2.invert(m1, n)

if t < 0:
    t = -t
    m2 = gmpy2.invert(m2, n)

m = (gmpy2.powmod(m1, s, n) * gmpy2.powmod(m2, t, n)) % n
m = long_to_bytes(m)
print(m)
# BJD{r3a_C0mmoN_moD@_4ttack}
```

> flag{r3a_C0mmoN_moD@_4ttack}

## 编码与调制

> 知识点：曼切斯特编码

> 题解

```python
# -*- coding: utf-8 -*-
# @Author: JanKinCai
# @Date:   2020-04-02 12:33:23
# @Last Modified by:   JanKinCai
# @Last Modified time: 2020-04-02 12:43:03
import textwrap


c = "2559659965656A9A65656996696965A6695669A9695A699569666A5A6A6569666A59695A69AA696569666AA6"
c = bytes.fromhex(c)
# 转换二进制
m = "".join([bin(v)[2:].zfill(8) for v in c])
# 10 --> 1, 01 --> 0
m = "".join([("1" if v == "10" else "0") for v in textwrap.wrap(m, 2)])
# 二进制转ASCII
m = "".join([chr(int(v, 2)) for v in textwrap.wrap(m, 8)])
print(m)
# BJD{DifManchestercode}
```

> flag{DifManchestercode}