# Crypto

## crypto-classic0

> 知识点：zip爆破，代码阅读

1. AZPR爆破工具，得到密码19990306

```python
print("".join([chr((v ^ 0x07) + 3) for v in b"Ygvdmq[lYate[elghqvakl}"]))
```

> flag{my_naive_encrytion}

## crypto-classic1

> 知识点：Vigenere密码

> 题解

1. 以``ACTF``为密钥，得到``SPSP{LXWG_S_SHNHIEPPB_USYRMOJR}``
2. ``SP``为密钥，得到``ACTF{TKXW_A_FIDPVFFXO_VIGENERE}``
3. 多次尝试，得到密钥``SPSPPSPSSSPSPSPSPSSPSPSPSP``

> flag{what_a_classical_vigenere}

## crypto-rsa0

> 知识点：zip伪加密，RSA解密

> 题解

```python
# -*- coding: utf-8 -*-
# @Author: JanKinCai
# @Date:   2020-03-15 02:13:05
# @Last Modified by:   JanKinCai
# @Last Modified time: 2020-04-03 18:47:23
# zip伪加密，把所有504B后几个字节09改成00
e = 65537
p = 9018588066434206377240277162476739271386240173088676526295315163990968347022922841299128274551482926490908399237153883494964743436193853978459947060210411
q = 7547005673877738257835729760037765213340036696350766324229143613179932145122130685778504062410137043635958208805698698169847293520149572605026492751740223
c = 50996206925961019415256003394743594106061473865032792073035954925875056079762626648452348856255575840166640519334862690063949316515750256545937498213476286637455803452890781264446030732369871044870359838568618176586206041055000297981733272816089806014400846392307742065559331874972274844992047849472203390350

d = gmpy2.invert(e, (p - 1) * (q - 1))
m = gmpy2.powmod(c, d, p * q)
m = long_to_bytes(m)
print(m)
```

> flag{n0w_y0u_see_RSA}

## crypto-rsa3

> 知识点：分解n、RSA解密

> 题解

```python
# -*- coding: utf-8 -*-
# @Author: JanKinCai
# @Date:   2020-03-15 02:13:05
# @Last Modified by:   JanKinCai
# @Last Modified time: 2020-04-03 18:36:11
import gmpy2
from Crypto.Util.number import *

# yafu分解n，得到p和q
p = 13326909050357447643526585836833969378078147057723054701432842192988717649385731430095055622303549577233495793715580004801634268505725255565021519817179293
q = 13326909050357447643526585836833969378078147057723054701432842192988717649385731430095055622303549577233495793715580004801634268505725255565021519817179231
e = 65537
c = 1457390378511382354771000540945361168984775052693073641682375071407490851289703070905749525830483035988737117653971428424612332020925926617395558868160380601912498299922825914229510166957910451841730028919883807634489834128830801407228447221775264711349928156290102782374379406719292116047581560530382210049

d = gmpy2.invert(e, (p - 1) * (q - 1))
m = gmpy2.powmod(c, d, p * q)
m = long_to_bytes(m)
print(m)
```

> flag{p_and_q_should_not_be_so_close_in_value}

## crypto-aes

> 知识点：XOR、AES解密

```python
from Crypto.Cipher import AES
from Crypto.Util.number import long_to_bytes, bytes_to_long


s = 91144196586662942563895769614300232343026691029427747065707381728622849079757
s = long_to_bytes(s)
c = b'\x8c-\xcd\xde\xa7\xe9\x7f.b\x8aKs\xf1\xba\xc75\xc4d\x13\x07\xac\xa4&\xd6\x91\xfe\xf3\x14\x10|\xf8p'

# 由于key的字节为2*16, iv为16，所以左边16个字节乘以2，得到key
key = s[:16] * 2
# XOR
iv = bytes_to_long(s[16:]) ^ bytes_to_long(key[16:])
iv = long_to_bytes(iv)

aes = AES.new(key, AES.MODE_CBC, iv)
flag = aes.decrypt(c)
print(flag)
# actf{W0W_y0u_can_so1v3_AES_now!}
```

> flag{W0W_y0u_can_so1v3_AES_now!}