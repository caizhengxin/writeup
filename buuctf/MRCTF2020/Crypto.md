# Crypto

## 古典密码知多少

> 知识点：标准银河字母，猪圈变形，栅栏密码

> 题解

1. 网上找对应表，得到FGCPFLIRTUASYON
2. 栅栏3, FLAGISCRYPTOFUN

> flag{CRYPTOFUN}

## babyRSA

> 知识点：代码阅读、数学

> 题解

```python
# -*- coding: utf-8 -*-
# @Author: JanKinCai
# @Date:   2020-03-15 02:13:05
# @Last Modified by:   JanKinCai
# @Last Modified time: 2020-04-02 21:03:20
import gmpy2
import sympy
from Crypto.Util.number import long_to_bytes

e = 65537
c = 1709187240516367141460862187749451047644094885791761673574674330840842792189795049968394122216854491757922647656430908587059997070488674220330847871811836724541907666983042376216411561826640060734307013458794925025684062804589439843027290282034999617915124231838524593607080377300985152179828199569474241678651559771763395596697140206072537688129790126472053987391538280007082203006348029125729650207661362371936196789562658458778312533505938858959644541233578654340925901963957980047639114170033936570060250438906130591377904182111622236567507022711176457301476543461600524993045300728432815672077399879668276471832

# 求p
P_p = 206027926847308612719677572554991143421
P_factor = 213671742765908980787116579976289600595864704574134469173111790965233629909513884704158446946409910475727584342641848597858942209151114627306286393390259700239698869487469080881267182803062488043469138252786381822646126962323295676431679988602406971858136496624861228526070581338082202663895710929460596143281673761666804565161435963957655012011051936180536581488499059517946308650135300428672486819645279969693519039407892941672784362868653243632727928279698588177694171797254644864554162848696210763681197279758130811723700154618280764123396312330032986093579531909363210692564988076206283296967165522152288770019720928264542910922693728918198338839


# P_p == P[9], 找到P[0]
for i in range(9):
    P_p = sympy.prevprime(P_p)


def gen_p():
    P = [0 for i in range(17)]
    P[0] = 206027926847308612719677572554991142909

    for i in range(1, 17):
        P[i] = sympy.nextprime(P[i-1])

    n = 1
    phi_n = 1

    for i in range(17):
        phi_n *= P[i] - 1
        n *= P[i]

    p = pow(P_factor, gmpy2.invert(e, phi_n), n)
    return sympy.nextprime(p)


p = gen_p()

# 求q
# q = sub_Q ** Q_2 % Q_1
Q_1 = 103766439849465588084625049495793857634556517064563488433148224524638105971161051763127718438062862548184814747601299494052813662851459740127499557785398714481909461631996020048315790167967699932967974484481209879664173009585231469785141628982021847883945871201430155071257803163523612863113967495969578605521
Q_2 = 151010734276916939790591461278981486442548035032350797306496105136358723586953123484087860176438629843688462671681777513652947555325607414858514566053513243083627810686084890261120641161987614435114887565491866120507844566210561620503961205851409386041194326728437073995372322433035153519757017396063066469743
sub_Q = 168992529793593315757895995101430241994953638330919314800130536809801824971112039572562389449584350643924391984800978193707795909956472992631004290479273525116959461856227262232600089176950810729475058260332177626961286009876630340945093629959302803189668904123890991069113826241497783666995751391361028949651
q = sympy.nextprime(pow(sub_Q, Q_2, Q_1))

# 求d
d = gmpy2.invert(e, (p - 1) * (q - 1))
m = gmpy2.powmod(c, d, p * q)
m = long_to_bytes(m)
print(m)
# MRCTF{sti11_@_b@by_qu3st10n}
```

> flag{sti11_@_b@by_qu3st10n}

## Keyboard

> 知识点：九键键盘

> 题解

```python
"""
九键键盘，从左开始，重复表示往右第几个字母

6    -   m
666  -   o
22   -   b
444  -   i
555  -   l
33   -   e
7    -   p
44   -   h
666  -   o
66   -   n
3    -   d

尝试flag{mobilephond}不行，按照单词意思，d->e

flag{mobilephone}
"""
```

> flag{mobilephone}

## 天干地支+甲子

> 知识点：天干地支+甲子对应表

> 题解

```python
"""
http://114.xixik.com/tiangandizhi/#anchor3
60年

甲戌 = 60 + 11
甲寅 = 60 + 51
甲寅 = 60 + 51
癸卯 = 60 + 40
己酉 = 60 + 46 
甲寅 = 60 + 51
辛丑 = 60 + 38
"""

print("".join([chr(60 + v) for v in [11, 51, 51, 40, 46, 51, 38]]))
# Goodjob
```

> flag{Goodjob}